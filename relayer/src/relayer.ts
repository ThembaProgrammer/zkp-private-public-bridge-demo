/**
 * relayer.ts
 * ----------
 * Cross-chain ZKP relayer service.
 *
 * Flow:
 *  1. Connects to the private GoQuorum node (port 8545) and listens for
 *     HouseFullyApproved(houseId) events from HouseTokenizingGovernance.
 *  2. When an event fires, generates a Groth16 proof off-chain via snarkjs
 *     (proving agentApproved=1, bankApproved=1 with houseId as public signal).
 *  3. Calls HouseToken.mintHouseToken() on the public Hardhat node (port 8546).
 *
 * Usage:
 *   cd relayer && npx ts-node src/relayer.ts
 */

import * as path   from "path";
import * as fs     from "fs";
import * as dotenv from "dotenv";
import { ethers }  from "ethers";
// @ts-ignore — snarkjs ships CJS types
import * as snarkjs from "snarkjs";

dotenv.config({ path: path.join(__dirname, "../../.env") });

// ── Config ────────────────────────────────────────────────────────────────
const QUORUM_RPC   = process.env.QUORUM_RPC_URL       || "http://127.0.0.1:8545";
const HARDHAT_RPC  = process.env.HARDHAT_RPC_URL      || "http://127.0.0.1:8546";
const RELAYER_PK    = process.env.RELAYER_PRIVATE_KEY  || "";
const RECIPIENT     = process.env.NFT_RECIPIENT        || "";
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL_MS || "3000", 10);

// Paths to circuit artifacts (generated by compile-circuit.sh)
const WASM_PATH    = path.join(__dirname, "../../circuits/houseApproval_js/houseApproval.wasm");
const ZKEY_PATH    = path.join(__dirname, "../../circuits/circuit_final.zkey");
const VK_PATH      = path.join(__dirname, "../../circuits/verification_key.json");

// Deployed contract addresses (written by deploy scripts)
const DEPLOYED     = JSON.parse(
  fs.readFileSync(path.join(__dirname, "../../relayer/.deployed.json"), "utf8")
);

// ── Minimal ABIs ─────────────────────────────────────────────────────────
const GOVERNANCE_ABI = [
  "event HouseFullyApproved(uint256 indexed houseId)",
  "function getApprovalState(uint256 houseId) view returns (bool, bool, bool, bool)",
];

const HOUSE_TOKEN_ABI = [
  "function mintHouseToken(uint256 houseId, uint[2] _pA, uint[2][2] _pB, uint[2] _pC, uint[1] _pubSignals, address recipient) external",
  "function minted(uint256) view returns (bool)",
];

// ── Helpers ───────────────────────────────────────────────────────────────

async function generateProof(houseId: bigint): Promise<{
  calldata: {
    _pA:        [bigint, bigint];
    _pB:        [[bigint, bigint], [bigint, bigint]];
    _pC:        [bigint, bigint];
    _pubSignals:[bigint];
  };
  valid: boolean;
}> {
  console.log(`  [ZKP] Generating Groth16 proof for houseId=${houseId}...`);

  // Private witnesses — in production these would come from a confidential
  // data store or be attested by the private chain oracle.
  const input = {
    agentApproved: "1",
    bankApproved:  "1",
    houseId:    houseId.toString(),
  };

  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    input,
    WASM_PATH,
    ZKEY_PATH,
  );

  // Optional: local sanity-check using the verification key
  const vKey = JSON.parse(fs.readFileSync(VK_PATH, "utf8"));
  const valid = await snarkjs.groth16.verify(vKey, publicSignals, proof);
  console.log(`  [ZKP] Local verification: ${valid ? "PASS ✓" : "FAIL ✗"}`);

  // Convert to Solidity calldata format
  const rawCalldata: string = await snarkjs.groth16.exportSolidityCallData(proof, publicSignals);
  const parsed: [string, string, string, string[]] = JSON.parse(`[${rawCalldata}]`);

  const _pA:        [bigint, bigint]               = [BigInt(parsed[0][0]), BigInt(parsed[0][1])];
  const _pB:        [[bigint,bigint],[bigint,bigint]] = [
    [BigInt(parsed[1][0][0]), BigInt(parsed[1][0][1])],
    [BigInt(parsed[1][1][0]), BigInt(parsed[1][1][1])],
  ];
  const _pC:        [bigint, bigint]               = [BigInt(parsed[2][0]), BigInt(parsed[2][1])];
  const _pubSignals:[bigint]                        = [BigInt(parsed[3][0])];

  return { calldata: { _pA, _pB, _pC, _pubSignals }, valid };
}

async function mintOnPublicChain(
  houseToken: ethers.Contract,
  houseId: bigint,
  pA:         [bigint, bigint],
  pB:         [[bigint,bigint],[bigint,bigint]],
  pC:         [bigint, bigint],
  pubSignals: [bigint],
  recipient:  string
): Promise<void> {
  console.log(`  [Mint] Calling mintHouseToken on public chain...`);

  // Check if already minted (idempotency guard)
  const alreadyMinted: boolean = await houseToken.minted(houseId);
  if (alreadyMinted) {
    console.log(`  [Mint] Token for houseId=${houseId} already minted — skipping.`);
    return;
  }

  const tx = await houseToken.mintHouseToken(
    houseId,
    pA,
    pB,
    pC,
    pubSignals,
    recipient,
  );

  console.log(`  [Mint] Tx sent: ${tx.hash}`);
  const receipt = await tx.wait();
  console.log(`  [Mint] Confirmed in block ${receipt.blockNumber} ✓`);
}

// ── Main Loop ─────────────────────────────────────────────────────────────

async function main() {
  // Validate env
  if (!RELAYER_PK)  throw new Error("RELAYER_PRIVATE_KEY is not set in .env");
  if (!RECIPIENT)   throw new Error("NFT_RECIPIENT is not set in .env");
  if (!fs.existsSync(WASM_PATH)) throw new Error(`WASM not found: ${WASM_PATH}. Run compile-circuit.sh first.`);
  if (!fs.existsSync(ZKEY_PATH)) throw new Error(`zkey not found: ${ZKEY_PATH}. Run compile-circuit.sh first.`);

  // ── Providers & signers ─────────────────────────────────────────────────
  const quorumProvider  = new ethers.JsonRpcProvider(QUORUM_RPC,  undefined, { polling: true, pollingInterval: POLL_INTERVAL });
  const hardhatProvider = new ethers.JsonRpcProvider(HARDHAT_RPC, undefined, { polling: true, pollingInterval: POLL_INTERVAL });
  const relayerSigner   = new ethers.Wallet(RELAYER_PK, hardhatProvider);

  console.log("\n╔══════════════════════════════════════════════════════╗");
  console.log("║        ZKP Cross-Chain Relayer — starting up         ║");
  console.log("╚══════════════════════════════════════════════════════╝");
  console.log(`  GoQuorum   → ${QUORUM_RPC}`);
  console.log(`  Hardhat    → ${HARDHAT_RPC}`);
  console.log(`  Governance → ${DEPLOYED.governance}`);
  console.log(`  HouseToken → ${DEPLOYED.houseToken}`);
  console.log(`  Recipient  → ${RECIPIENT}`);
  console.log(`  Relayer    → ${relayerSigner.address}\n`);

  // ── Contracts ───────────────────────────────────────────────────────────
  const governance = new ethers.Contract(DEPLOYED.governance, GOVERNANCE_ABI, quorumProvider);
  const houseToken = new ethers.Contract(DEPLOYED.houseToken, HOUSE_TOKEN_ABI, relayerSigner);

  // ── Event listener ───────────────────────────────────────────────────────
  console.log("Listening for HouseFullyApproved events on GoQuorum...\n");

  governance.on("HouseFullyApproved", async (houseId: bigint, event: ethers.EventLog) => {
    const id = BigInt(houseId.toString());
    console.log(`\n[Event] HouseFullyApproved detected!`);
    console.log(`  houseId : ${id}`);
    console.log(`  block      : ${event.blockNumber}`);
    console.log(`  txHash     : ${event.transactionHash}`);

    try {
      // Generate ZKP
      const { calldata, valid } = await generateProof(id);
      if (!valid) {
        console.error("  [ZKP] Proof failed local verification — aborting mint.");
        return;
      }

      // Mint on public chain
      await mintOnPublicChain(
        houseToken,
        id,
        calldata._pA,
        calldata._pB,
        calldata._pC,
        calldata._pubSignals,
        RECIPIENT,
      );

      console.log(`\n[OK] Token #${id} successfully minted on public chain.\n`);
    } catch (err) {
      console.error(`\n[Error] Failed to relay houseId=${id}:`, err);
    }
  });

  // Keep process alive
  process.on("SIGINT", () => {
    console.log("\nRelayer shutting down...");
    process.exit(0);
  });
}

main().catch((err) => {
  console.error("Fatal:", err);
  process.exit(1);
});
